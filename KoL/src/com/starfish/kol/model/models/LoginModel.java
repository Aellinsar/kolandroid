package com.starfish.kol.model.models;

import java.io.Serializable;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import com.starfish.kol.connection.Connection.ServerReply;
import com.starfish.kol.connection.Session;
import com.starfish.kol.gamehandler.GameHandler;
import com.starfish.kol.gamehandler.ViewContext;
import com.starfish.kol.model.Model;
import com.starfish.kol.model.models.LoginModel.LoginStatus;
import com.starfish.kol.request.Request;
import com.starfish.kol.request.ResponseHandler;
import com.starfish.kol.request.SingleRequest;
import com.starfish.kol.util.Regex;

public class LoginModel extends Model<LoginStatus> {
	/**
	 * Autogenerated by eclipse.
	 */
	private static final long serialVersionUID = -8728194484440083488L;

	private static final Regex SERVER = new Regex("^appserver=(.*)$", 1);

	private static final Regex LOGIN_ID = new Regex(
			".*/login.php\\?loginid=(.*)", 1);
	private static final Regex CHALLENGE = new Regex(
			"<input type=hidden name=challenge value=\"([^\"]*?)\">", 1);

	public LoginModel() {
		super(new Session());
	}
	
	public void cheat(ViewContext context) {
		Request req = new Request("static.php?id=whatiskol",
				new GameHandler(context));
		this.makeRequest(req);
	}

	public void login(final ViewContext context, final String username, final PasswordHash hash) {
		this.notifyView(LoginStatus.STARTING);

		Request req = new Request("login.php", new ResponseHandler() {
			@Override
			public boolean handle(Session session, Request request,
					ServerReply response) {
				String loginId = LOGIN_ID.extractSingle(response.url);
				String challenge = CHALLENGE.extractSingle(response.html);
				String server = SERVER.extractSingle(response.cookie);

				if (loginId == null || challenge == null || server == null) {
					notifyView(LoginStatus.FAILED_ACCESS);
					return true;
				}

				session.setCookie(response.cookie);
				String[] names = { "loginid", "loginname", "password",
						"loggingin", "challenge", "response", "secure" };
				String[] vals = { loginId, username, "", "Yup.", challenge,
						hash.completeChallenge(challenge), "1" };
				notifyView(LoginStatus.HALFWAY);

				Request login = new SingleRequest("login.php", names, vals,
						new ResponseHandler() {

							@Override
							public boolean handle(Session session,
									Request request, ServerReply response) {
								System.out.println("Logincookie: "
										+ response.cookie);
								if (!response.cookie.contains("PHPSESSID=")) {
									// Failure to login
									notifyView(LoginStatus.FAILED_LOGIN);
									return true;
								}

								notifyView(LoginStatus.SUCCESS);

								session.setCookie(response.cookie);
								Request game = new Request("main.php", new GameHandler(context));
								// Request game = new
								// Request("craft.php?mode=combine",
								// ResponseHandler.none);
								game.makeAsync(session);
								return true;
							}

						});

				login.makeAsync(session);
				return true;
			}
		});
		this.makeRequest(req);
	}
	
	public enum LoginStatus {
		STARTING, HALFWAY, SUCCESS, FAILED_ACCESS, FAILED_LOGIN;
	}
	
	public static class PasswordHash implements Serializable
	{
		/**
		 * Autogenerated by eclipse.
		 */
		private static final long serialVersionUID = -3913668500864943263L;
		
		private final String hash;
		
		public PasswordHash(String password, boolean prehashed) {
			if(prehashed)
				hash = password;
			else
				this.hash = getHash(password);
		}
		
		protected String completeChallenge(String challenge) {
			return getHash(hash + ":" + challenge);
		}
		
		public String getBaseHash() {
			return hash;
		}
		
		private static String getHash(String value) {
			try {
				MessageDigest digester = MessageDigest.getInstance("MD5");
				return getHexString(digester.digest(value.getBytes()));
			} catch (NoSuchAlgorithmException e) {
				e.printStackTrace();
				return "";
			}
		}
		
		private static String getHexString(final byte[] bytes) {
			byte[] output = new byte[bytes.length + 1];
			for (int i = 0; i < bytes.length; ++i) {
				output[i + 1] = bytes[i];
			}

			StringBuffer result = new StringBuffer(
					(new BigInteger(output)).toString(16));
			int desiredLength = bytes.length * 2;

			while (result.length() < desiredLength) {
				result.insert(0, '0');
			}

			if (result.length() > desiredLength) {
				result.delete(0, result.length() - desiredLength);
			}

			return result.toString();
		}
	}
}
